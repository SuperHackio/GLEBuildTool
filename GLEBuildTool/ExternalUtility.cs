using System.Diagnostics;
using System.Text;

namespace GLEBuildTool;

public static class ExternalUtility
{
    public const string GLE_HEADER =
        /*lang=cpp*/
        """
        #pragma once

        #include "syati.h"

        /* === GALAXY LEVEL ENGINE ===
        *  - Syati Function Bindings -
        *
        *  These are Automatically generated by GLEBuildTool.
        *  DO NOT MODIFY THIS FILE!
        *  If a mistake occured while generating this header, please let me know.
        *  https://www.github.com/SuperHackio/GalaxyLevelEngine/issues
        *
        *  Generation Information:
        {1}
        */

        {0}
        """;

    public const string MODULE_JSON =
        /*lang=json*/
        """
        {
          "Name": "Galaxy Level Engine",
          "Author": "Super Hackio",
          "Description": "Syati Bindings for Galaxy Level Engine functions.",
          "APIId": "GalaxyLevelEngine_API",
          "CompilerFlags": [
            "-DGALAXY_LEVEL_ENGINE"
          ],

          "GLEBuildTool": [
        "####"
          ]####
        }
        """;


    public const string GLE_HEADER_HOOK_GEN =
        /*lang=cpp*/
        """
        #pragma once

        /* === GALAXY LEVEL ENGINE ===
        *  - Syati Function Hook Codegen -
        *
        *  These are Automatically generated by GLEBuildTool.
        *  DO NOT MODIFY THIS FILE!
        *  If a mistake occured while generating this header, please let me know.
        *  https://www.github.com/SuperHackio/GalaxyLevelEngine/issues
        *
        *  Generation Information:
        {1}
        */

        {0}
        """;

    public const string GLE_HOOK_GEN_TEMPLATE =
        """
        {0}

        typedef {7} (*HookFunc{1}Def)({2});

        const HookFunc{1}Def cModule{3}Table[] = {5}
            NULL,
        {4}
        {6};
        const s32 cModule{3}TableCount = sizeof(cModule{3}Table) / sizeof(HookFunc{1}Def);


        """;

    public const string GLE_HOOK_MODULEINFO_MODULEEXTENSIONDEFINITION_TEMPLATE =
        /*lang=json*/
        """
            {
              "Name": ""#"",
              "CodeGenSource": "GEN_GalaxyLevelEngine_Hooks.h",
              "CodeGenDestination": "codebuild/ModuleData_GalaxyLevelEngine_Hooks.h",
              "Variables": [
        "##"
              ],
              "CodeGenData": [
        "###"
              ]
            }
        """;

    public const string GLE_HOOK_MODULEINFO_CODEGENDATA_TEMPLATE =
        """
                {
                  "ReplaceTargetName": ""#"",
                  "ReplaceFormatData": ""##""
                }
        """;

    public const string GLE_SOURCE_HOOK =
        /*lang=cpp*/
        """
        #pragma once
                
        #include "syati.h"
        #include "ModuleData_GalaxyLevelEngine_Hooks.h"

        /* === GALAXY LEVEL ENGINE ===
        *  - Syati Function Hooks -
        *
        *  These are Automatically generated by GLEBuildTool.
        *  DO NOT MODIFY THIS FILE!
        *  If a mistake occured while generating this header, please let me know.
        *  https://www.github.com/SuperHackio/GalaxyLevelEngine/issues
        *
        *  Generation Information:
        {1}
        */

        {0}
        """;

    public const string GLE_SOURCE_HOOK_SYMBOL = "extern const u8 {0};";
    public const string GLE_SOURCE_HOOK_EXTERN_NAME = "__hk__{0}";
    public const string GLE_SOURCE_HOOK_TEMPLATE =
        /*lang=cpp*/
        """
        <#EXTERN>

        namespace GLE_HOOK_NAMESPACE {
            <#RETURN> <#FUNCNAME>(<#FUNCPARAMDEFINE>) {
                <#FUNCSTARTCONTENT>
                for (s32 i = 1; i < <#HOOKLISTCOUNT>; i++)
                {
                    <#FUNCLOOPCONTENT>
                }
                <#FUNCRETURNCONTENT>
            }
            <#KAMEKHOOKTYPE>(&<#EXTERNNAME>, <#FUNCNAME>);
        }

        // ----------------------------------------------------------------------------------------------------------------

        """;

    public const string SYMBOL_FORMAT = "{0}=0x{1}";



    public class GLESymbolDefinition(uint addr)
    {
        public string? Name;
        public readonly uint Address = addr;
        public List<string> Description = [];
        public Dictionary<int, (string Name, List<string> Description)> ParameterDescriptions = [];
        public string? ReturnType;
        public List<string> ReturnInfo = [];
        public List<string> CrashInfo = [];

        public string? DemangledName => string.IsNullOrWhiteSpace(Name) ? null : SymbolUtility.Demangle(Name);
    }

    public class GLEHookDefinition(uint addr)
    {
        public string? Name;
        public readonly uint Address = addr;
        public List<string> Description = [];
        public Dictionary<int, (string Name, List<string> Description)> ParameterDescriptions = [];
        public string? ReturnType;
        public string? HookType;
        public string? KamekType;
        public List<string> ReturnInfo = [];

        public string? DemangledName => string.IsNullOrWhiteSpace(Name) ? null : SymbolUtility.Demangle(Name);


        public string? GetFuncStartContents() => HookType switch
        {
            // Simply execute all of the functions in the list
            "Void" => "",

            // Treat the functions in the list as a chain of && checks. The first one to fail returns false, otherwise if all succeed, return true.
            "boolean_and" => "",

            // Treat the functions in the list as a chain of || checks. If any one of the checks succeed, returns true, otherwise if none succeed, return false.
            "boolean_or" => "",

            _ => throw new NotImplementedException($"Function Return contents for Hook Type \'{HookType}\' have not been implemented!"),
        };

        public string? GetFuncLoopContents() => HookType switch
        {
            "Void" =>
            """
            <#HOOKLIST>[i](<#FUNCPARAM>);
            """,

            "boolean_and" =>
            """
            if (!<#HOOKLIST>[i](<#FUNCPARAM>))
                return false;
            """,

            "boolean_or" =>
            """
            if (<#HOOKLIST>[i](<#FUNCPARAM>))
                return true;
            """,

            _ => throw new NotImplementedException($"Function Loop contents for Hook Type \'{HookType}\' have not been implemented!"),
        };

        public string? GetFuncReturnContents() => HookType switch
        {
            "Void" => "",

            "boolean_and" =>
            """
            return true;
            """,

            "boolean_or" =>
            """
            return false;
            """,

            _ => throw new NotImplementedException($"Function Return contents for Hook Type \'{HookType}\' have not been implemented!"),
        };
    }


    public static void GenerateExternalsData(string RegionShort, List<GLESymbolDefinition> Externals, List<GLEHookDefinition> Hooks)
    {
        if (Externals.Count == 0)
            return; //No externals to generate

        Console.WriteLine("Generating Externals...");

        // Unlike the other output folders, we're not gonna delete the externals folder
        string ExternalsFolder = Program.ExternalsOutputPath();
        if (!Directory.Exists(ExternalsFolder))
            Directory.CreateDirectory(ExternalsFolder);

        GenerateSyatiModule(ExternalsFolder, RegionShort, Externals, Hooks);
    }

    private static async void GenerateSyatiModule(string ExternalsFolder, string RegionShort, List<GLESymbolDefinition> Externals, List<GLEHookDefinition> Hooks)
    {
        // Create a folder for a Syati Module if it doesn't already exist
        string ModuleFolder = Path.Combine(ExternalsFolder, "GLE_API");
        if (!Directory.Exists(ModuleFolder))
            Directory.CreateDirectory(ModuleFolder);
        string IncludeFolder = Path.Combine(ModuleFolder, "include");
        if (!Directory.Exists(IncludeFolder))
            Directory.CreateDirectory(IncludeFolder);
        string SymbolsFolder = Path.Combine(ModuleFolder, "symbols");
        if (!Directory.Exists(SymbolsFolder))
            Directory.CreateDirectory(SymbolsFolder);
        string CodeGenFolder = Path.Combine(ModuleFolder, "codegen");
        if (!Directory.Exists(CodeGenFolder))
            Directory.CreateDirectory(CodeGenFolder);
        string SourceFolder = Path.Combine(ModuleFolder, "source");
        if (!Directory.Exists(SourceFolder))
            Directory.CreateDirectory(SourceFolder);

        Task TaskWriteGLEHeader,
            TaskWriteSymbolText,
            TaskModuleInfoJSON,
            TaskCodeGenHeader = Task.FromResult(0),
            TaskCodeGenSource = Task.FromResult(0);

        string MetadataString =
            $"""
                "Generated: {DateTime.Now:F}",
                "Symbol Count: {Externals.Count}",
                "Hook Count: {Hooks.Count}",
                "GLE Version: {Program.GLEVERSION.Replace('_', '.')}"
            """;

        // Time to generate the header. First, we have to deal with separating each External into a namespace
        Dictionary<string, List<GLESymbolDefinition>> Namespaces = [];
        for (int i = 0; i < Externals.Count; i++)
        {
            GLESymbolDefinition def = Externals[i];

            string? DemangledName = def.DemangledName;
            if (DemangledName is null)
            {
                Debugger.Break();
                continue;
            }
            string[] NamespaceSplit = DemangledName[..DemangledName.IndexOf('(')].Split("::");

            string NamespaceKey = "";
            for (int j = 0; j < NamespaceSplit.Length-1; j++)
            {
                NamespaceKey += NamespaceSplit[j] + "::";
            }

            if (!Namespaces.ContainsKey(NamespaceKey))
                Namespaces.Add(NamespaceKey, []);
            Namespaces[NamespaceKey].Add(def);
        }
        ;
        StringBuilder sb = new();
        // Time to build the header contents!
        List<string> namespaceKeys = [.. Namespaces.Keys];
        namespaceKeys.Sort();
        for (int i = 0; i < namespaceKeys.Count; i++)
        {
            string CurrentNamespace = namespaceKeys[i];
            if (CurrentNamespace.Equals("GLE::"))
                sb.AppendLine("// Galaxy Level Engine");
            sb.Append($"namespace ").Append(CurrentNamespace[..^2]).Append(" {\n");
            List<GLESymbolDefinition> Definitions = Namespaces[CurrentNamespace];
            for (int j = 0; j < Definitions.Count; j++)
            {
                GLESymbolDefinition def = Definitions[j];
                string? Demangled = def.DemangledName;
                if (Demangled is null)
                    continue; // Failed to demangle. Need an actual warning later...

                string DemangleNoNamespace = Demangled[CurrentNamespace.Length..];
                string DemangleSignatureOnly = DemangleNoNamespace[(DemangleNoNamespace.IndexOf('(')+1)..^1];
                string DemangleNameOnly = DemangleNoNamespace[..^(DemangleSignatureOnly.Length+2)];
                string[] Parameters = DemangleSignatureOnly.Split(',', StringSplitOptions.TrimEntries);

                string FunctionDocHeader =
                """
                    /**
                {0}
                      **/

                """;
                StringBuilder FunctionDoc = new();
                for (int l = 0; l < def.Description.Count; l++)
                    FunctionDoc.Append(@"      * \brief ").AppendLine(def.Description[l]);
                if (def.Description.Count > 0)
                    FunctionDoc.Append("      *\n"); //Spacer

                string func = $"    {def.ReturnType ?? "void"} {DemangleNameOnly}({{0}});\n";
                StringBuilder ParamBuilder = new();
                for (int k = 0; k < Parameters.Length; k++)
                {
                    if (!def.ParameterDescriptions.TryGetValue(k, out (string Name, List<string> Desc) result))
                    {
                        // No additional definition
                        ParamBuilder.Append(Parameters[k]);
                        goto TryAppendFinal;
                    }
                    ParamBuilder.Append(Parameters[k]).Append(' ').Append(result.Name);

                    for (int l = 0; l < result.Desc.Count; l++)
                    {
                        if (l == 0)
                            FunctionDoc.Append(@"      * \param ").Append(result.Name);
                        else
                            FunctionDoc.AppendLine(@"      * ").Append(@"      * "); //Blank separator, open next line
                        FunctionDoc.Append(' ').AppendLine(result.Desc[l]);
                    }


                TryAppendFinal:
                    if (k < Parameters.Length - 1)
                        ParamBuilder.Append(", ");
                }
                if (def.ParameterDescriptions.Count > 0)
                    FunctionDoc.Append("      *\n"); //Spacer

                for (int l = 0; l < def.ReturnInfo.Count; l++)
                    FunctionDoc.Append(@"      * \return ").AppendLine(def.ReturnInfo[l]);
                if (def.ReturnInfo.Count > 0)
                    FunctionDoc.Append("      *\n"); //Spacer

                for (int l = 0; l < def.CrashInfo.Count; l++)
                    FunctionDoc.Append(@"      * \throw ").AppendLine(def.CrashInfo[l]);

                string functionHeaderFinal = FunctionDoc.ToString();
                if (!string.IsNullOrWhiteSpace(functionHeaderFinal))
                    functionHeaderFinal = functionHeaderFinal.TrimEnd();

                sb.AppendFormat(FunctionDocHeader, functionHeaderFinal);
                sb.AppendFormat(func, ParamBuilder.ToString());
            }
            sb.Append("}\n\n");
        }
        string HeaderData = sb.ToString();
        string FinalHeader = string.Format(GLE_HEADER, HeaderData, MetadataString);
        TaskWriteGLEHeader = File.WriteAllTextAsync(Path.Combine(IncludeFolder, "GalaxyLevelEngine.h"), FinalHeader);

        // Prepare the Symbols file!
        List<string> ExternalSymbolList = new(Externals.Count);
        foreach (var externalSymbol in Externals)
            ExternalSymbolList.Add(string.Format(SYMBOL_FORMAT, externalSymbol.Name, externalSymbol.Address.ToString("X8")));

        
        StringBuilder CodeGenBuilder = new(), SourceBuilder = new(), ModuleInfoBuilder = new();
        if (Hooks.Count == 0)
            goto SkipAllHooks;


        // Now we can do Hooks
        // Start by doing the Codegen file

        ModuleInfoBuilder.AppendLine(@"  ""ModuleExtensionDefinition"": [");

        for (int i = 0; i < Hooks.Count; i++)
        {
            GLEHookDefinition CurrentHook = Hooks[i];
            if (CurrentHook.DemangledName is not string Deman)
            {
                //ERROR
                continue;
            }
            string HookName = Deman.Replace("::", "__")[..Deman.IndexOf('(')];
            string HookParam = Deman[(Deman.IndexOf('(')+1)..^1];
            string HookList = HookName + "List";
            string HookIncludeList = "IncludeList" + HookName;

            // Hook with Include list
            {
                CodeGenBuilder.AppendFormat(GLE_HOOK_GEN_TEMPLATE, "{{" + HookIncludeList + "}}", HookName, HookParam, HookName, "{{" + HookList + "}}", '{', '}', CurrentHook.ReturnType);

                string values =
                    """
                            "Name",
                            "Function",
                            "Include"
                    """;
                string t = GLE_HOOK_MODULEINFO_CODEGENDATA_TEMPLATE.Replace("\"#\"", HookList).Replace("\"##\"", "{1}, //{0}");
                string tt = GLE_HOOK_MODULEINFO_CODEGENDATA_TEMPLATE.Replace("\"#\"", HookIncludeList).Replace("\"##\"", "#include \\\"{2}\\\"");
                ModuleInfoBuilder.Append(GLE_HOOK_MODULEINFO_MODULEEXTENSIONDEFINITION_TEMPLATE.Replace("\"#\"", HookName).Replace("\"##\"", values).Replace("\"###\"", t +","+ Environment.NewLine + tt));
                if (i < Hooks.Count - 1)
                    ModuleInfoBuilder.AppendLine(",");
                else
                    ModuleInfoBuilder.AppendLine();

                string HookSymbolName = string.Format(GLE_SOURCE_HOOK_EXTERN_NAME, HookName);
                ExternalSymbolList.Add(string.Format(SYMBOL_FORMAT, HookSymbolName, CurrentHook.Address.ToString("X8")));

                string CurrentHookCode = GLE_SOURCE_HOOK_TEMPLATE
                    .Replace("<#FUNCSTARTCONTENT>", CurrentHook.GetFuncStartContents())
                    .Replace("<#FUNCLOOPCONTENT>", CurrentHook.GetFuncLoopContents())
                    .Replace("<#FUNCRETURNCONTENT>", CurrentHook.GetFuncReturnContents())
                    .Replace("<#EXTERN>", string.Format(GLE_SOURCE_HOOK_SYMBOL, HookSymbolName))
                    .Replace("<#RETURN>", CurrentHook.ReturnType ?? "void")
                    .Replace("<#FUNCNAME>", HookName)
                    .Replace("<#FUNCPARAMDEFINE>", CreateFunctionParamDefine())
                    .Replace("<#FUNCPARAM>", CreateFunctionParam())
                    .Replace("<#HOOKLIST>", $"cModule{HookName}Table")
                    .Replace("<#HOOKLISTCOUNT>", $"cModule{HookName}TableCount")
                    .Replace("<#KAMEKHOOKTYPE>", CurrentHook.KamekType)
                    .Replace("<#EXTERNNAME>", HookSymbolName);
                SourceBuilder.AppendLine(CurrentHookCode);
            }

            string CreateFunctionParamDefine()
            {
                string[] ParamTypes = HookParam.Split(',');
                string result = "";
                for (int x = 0; x < ParamTypes.Length; x++)
                {
                    string cur = ParamTypes[x];
                    cur += " ";
                    cur += CurrentHook.ParameterDescriptions[0].Name;
                    if (x < ParamTypes.Length-1)
                        cur += ",";
                    result += cur;
                }
                return result;
            }
            string CreateFunctionParam()
            {
                string result = "";
                int x = 0;
                foreach (var item in CurrentHook.ParameterDescriptions)
                {
                    result += item.Value.Name;
                    if (x < CurrentHook.ParameterDescriptions.Count - 1)
                        result += ", ";
                    x++;
                }
                return result;
            }
        }
        ModuleInfoBuilder.AppendLine(@"  ]");

        string FinalCodeGenHeader = string.Format(GLE_HEADER_HOOK_GEN, CodeGenBuilder.ToString(), MetadataString);
        TaskCodeGenHeader = File.WriteAllTextAsync(Path.Combine(CodeGenFolder, "GEN_GalaxyLevelEngine_Hooks.h"), FinalCodeGenHeader);
        string FinalCodeGenSource = string.Format(GLE_SOURCE_HOOK, SourceBuilder.ToString(), MetadataString);
        TaskCodeGenSource = File.WriteAllTextAsync(Path.Combine(SourceFolder, "GalaxyLevelEngine_Hooks.cpp"), FinalCodeGenSource);

    SkipAllHooks:
        // This is down here to ensure we get the hook symbols as well... because this actually works this way, which tbh surprised me, but we take those
        TaskWriteSymbolText = File.WriteAllLinesAsync(Path.Combine(SymbolsFolder, $"{REGIONS_SYATI[Array.IndexOf(REGIONS_GLE, RegionShort)]}.txt"), ExternalSymbolList);

        // Create the ModuleInfo
        if (Hooks.Count == 0)
        {
            string ModuleInfo = MODULE_JSON.Replace("\"####\"", MetadataString).Replace("####", "");
            TaskModuleInfoJSON = File.WriteAllTextAsync(Path.Combine(ModuleFolder, "ModuleInfo.json"), ModuleInfo);
        }
        else
        {
            // TODO: generate hooks
            string ModuleInfo = MODULE_JSON.Replace("\"####\"", MetadataString).Replace("####", "," + Environment.NewLine + ModuleInfoBuilder.ToString());
            TaskModuleInfoJSON = File.WriteAllTextAsync(Path.Combine(ModuleFolder, "ModuleInfo.json"), ModuleInfo);
        }

        await TaskWriteGLEHeader;
        await TaskWriteSymbolText;
        await TaskModuleInfoJSON;
        await TaskCodeGenHeader;
        await TaskCodeGenSource;
    }


    private static readonly string[] REGIONS_GLE = ["P", "E", "J", "W", "K"];
    private static readonly string[] REGIONS_SYATI = ["PAL", "USA", "JPN", "TWN", "KOR"];
}

internal static class SymbolUtility
{
    public static string Demangle(string symbol)
    {
        StringStream input = new(symbol);
        StringBuilder output = new(100);

        string name = DemangleName(input);
        string? type = null;
        string? prms = null;
        bool constant = false;

        if (input.Position < input.Length && input.Peek() != 'F')
        {
            DemangleType(input, output);
            type = output.ToString();
            output.Clear();
        }

        if (input.Peek() == 'C')
        {
            ++input.Position;
            constant = true;
        }

        if (input.Peek() == 'F')
        {
            ++input.Position;

            while (input.Position < input.Length)
            {
                if (output.Length > 0)
                    output.Append(", ");

                DemangleType(input, output);
            }

            prms = output.ToString();
            output.Clear();
        }

        if (type != null)
        {
            output.Append(type);
            output.Append("::");
        }

        if (name != null)
        {
            bool op = true;
            bool space = true;

            switch (name)
            {
                case "__ct":
                case "__dt":
                    if (type == null)
                        break;

                    if (name == "__dt")
                        output.Append('~');

                    name = type;
                    int index = type.IndexOf('<');

                    if (index >= 0)
                        name = name[..index];

                    index = name.LastIndexOf("::");

                    if (index >= 0)
                        name = name[(index + 2)..];

                    op = false;
                    space = false;
                    break;

                case "__nw": name = " new"; break;
                case "__nwa": name = " new[]"; break;
                case "__dl": name = " delete"; break;
                case "__dla": name = " delete[]"; break;
                case "__pl": name = "+"; break;
                case "__mi": name = "-"; break;
                case "__ml": name = "*"; break;
                case "__dv": name = "/"; break;
                case "__md": name = "%"; break;
                case "__er": name = "^"; break;
                case "__ad": name = "&"; break;
                case "__or": name = "|"; break;
                case "__co": name = "~"; break;
                case "__nt": name = "!"; break;
                case "__as": name = "="; break;
                case "__lt": name = "<"; break;
                case "__gt": name = ">"; break;
                case "__apl": name = "+="; break;
                case "__ami": name = "-="; break;
                case "__amu": name = "*="; break;
                case "__adv": name = "/="; break;
                case "__amd": name = "%="; break;
                case "__aer": name = "^="; break;
                case "__aad": name = "&="; break;
                case "__aor": name = "|="; break;
                case "__ls": name = "<<"; break;
                case "__rs": name = ">>"; break;
                case "__ars": name = ">>="; break;
                case "__als": name = "<<="; break;
                case "__eq": name = "=="; break;
                case "__ne": name = "!="; break;
                case "__le": name = "<="; break;
                case "__ge": name = ">="; break;
                case "__aa": name = "&&"; break;
                case "__oo": name = "||"; break;
                case "__pp": name = "++"; break;
                case "__mm": name = "--"; break;
                case "__cm": name = ","; break;
                case "__rm": name = "->*"; break;
                case "__rf": name = "->"; break;
                case "__cl": name = "()"; break;
                case "__vc": name = "[]"; break;

                default:
                    op = false;
                    space = false;
                    break;
            }

            if (op)
                output.Append("operator");

            output.Append(name);

            if (space)
                output.Append(' ');
        }

        if (prms != null)
        {
            output.Append('(');

            if (prms != "void")
                output.Append(prms);

            output.Append(')');
        }

        if (constant)
            output.Append(" const");

        string result = output.ToString();

        result = result.Replace("JGeometry::TVec2<f32>", "TVec2f");
        result = result.Replace("JGeometry::TVec3<f32>", "TVec3f");
        result = result.Replace("JGeometry::TPosition3<JGeometry::TMatrix34<JGeometry::SMatrix34C<f32>>>", "TPos3f");
        result = result.Replace("f32 (*) [4]", "MtxPtr");
        
        return result;
    }

    static string DemangleName(StringStream input)
    {
        StringBuilder output = new(100);
        int end = ScanNameEnd(input);

        while (input.Position < end)
        {
            char c = input.Read();

            if (c == '<')
                DemangleTemplate(input, output);
            else
                output.Append(c);
        }

        if (end < input.Length)
            input.Position += 2;

        return output.ToString();
    }

    static int ScanNameEnd(StringStream input)
    {
        int end = input.Length;

        for (int i = input.Position; i < input.Length; ++i)
        {
            if (input[i] != '_' || input[i + 1] != '_')
                continue;

            int digit_index = (i + 2);
            if (input[i + 2] == 'Q')
            {
                // Do nothing yippeee
            }
            else if (input[i + 2] != 'F')
            {
                char c = input[digit_index];

                if (c < '0' || c > '9')
                    continue;
            }

            end = i;
        }

        return end;
    }

    static void DemangleType(StringStream input, StringBuilder output)
    {
        char c = input.Peek();

        if (c == '-' || ('0' <= c && c <= '9'))
        {
            bool literal = false;
            bool negative = false;

            if (c == '-')
            {
                ++input.Position;
                c = input.Peek();

                literal = true;
                negative = true;
            }

            int length = 0;

            while ('0' <= c && c <= '9')
            {
                length *= 10;
                length += (c - '0');

                ++input.Position;
                c = input.Peek();
            }

            if (c == ',' || c == '>')
                literal = true;

            if (literal)
            {
                if (negative)
                    length = -length;

                output.Append(length);
            }
            else
            {
                int start = input.Position;

                while ((input.Position - start) < length)
                {
                    c = input.Read();

                    if (c == '<')
                        DemangleTemplate(input, output);
                    else
                        output.Append(c);
                }
            }
        }
        else
        {
            bool end = false;
            List<ComponentInfo> components = new(10);

            do
            {
                c = input.Read();
                StringBuilder name;
                switch (c)
                {
                    case 'C':
                        components.Insert(0, new ComponentInfo(ComponentType.Const));
                        break;
                    case 'P':
                        components.Insert(0, new ComponentInfo(ComponentType.Pointer));
                        break;
                    case 'R':
                        components.Insert(0, new ComponentInfo(ComponentType.Reference));
                        break;
                    case 'U':
                        components.Insert(0, new ComponentInfo(ComponentType.Unsigned));
                        break;
                    case 'A':
                        int length = 0;

                        while ((c = input.Read()) != '_')
                        {
                            length *= 10;
                            length += (c - '0');
                        }

                        components.Insert(0, new ComponentInfo(length));
                        break;
                    case 'e':
                        components.Insert(0, new ComponentInfo(ComponentType.Ellipsis));
                        end = true;
                        break;
                    case 'v':
                        components.Insert(0, new ComponentInfo(ComponentType.Void));
                        end = true;
                        break;
                    case 'b':
                        components.Insert(0, new ComponentInfo(ComponentType.Bool));
                        end = true;
                        break;
                    case 'c':
                        components.Insert(0, new ComponentInfo(ComponentType.Char));
                        end = true;
                        break;
                    case 'w':
                        components.Insert(0, new ComponentInfo(ComponentType.WChar));
                        end = true;
                        break;
                    case 's':
                        components.Insert(0, new ComponentInfo(ComponentType.Short));
                        end = true;
                        break;
                    case 'i':
                        components.Insert(0, new ComponentInfo(ComponentType.Int));
                        end = true;
                        break;
                    case 'l':
                        components.Insert(0, new ComponentInfo(ComponentType.Long));
                        end = true;
                        break;
                    case 'x':
                        components.Insert(0, new ComponentInfo(ComponentType.LongLong));
                        end = true;
                        break;
                    case 'f':
                        components.Insert(0, new ComponentInfo(ComponentType.Float));
                        end = true;
                        break;
                    case 'd':
                        components.Insert(0, new ComponentInfo(ComponentType.Double));
                        end = true;
                        break;
                    case 'Q':
                        int count = (input.Read() - '0');
                        name = new(100);

                        while (count-- > 0)
                        {
                            DemangleType(input, name);

                            if (count > 0)
                                name.Append("::");
                        }

                        components.Insert(0, new ComponentInfo(name.ToString()));
                        end = true;
                        break;
                    case 'F':
                        StringBuilder prms = new(100);
                        StringBuilder ret = new(100);

                        while (input.Peek() != '_')
                        {
                            if (prms.Length > 0)
                                prms.Append(", ");

                            DemangleType(input, prms);
                        }

                        // i.e. prefer "()" over "(void)"
                        string prms_str = prms.ToString();

                        if (prms_str == "void")
                            prms_str = "";

                        ++input.Position;
                        DemangleType(input, ret);
                        components.Insert(0, new ComponentInfo(prms_str, ret.ToString()));
                        end = true;
                        break;
                    default:
                        if ('0' <= c && c <= '9')
                        {
                            --input.Position;
                            name = new(100);
                            DemangleType(input, name);
                            components.Insert(0, new ComponentInfo(name.ToString()));
                            end = true;
                        }
                        if (c.Equals('\0'))
                            throw new Exception("Incorrectly mangled symbol.");
                        break;
                }
            } while (!end);

            // e.g. prefer "unsigned int" over "int unsigned"
            int const_index = 1;
            if (components.Count >= 2 && components[1].type == ComponentType.Unsigned)
            {
                components.RemoveAt(1);
                components.Insert(0, new ComponentInfo(ComponentType.Unsigned));
                ++const_index;
            }

            // e.g. prefer "const float *" over "float const *"
            if (components.Count >= (const_index + 1) && components[const_index].type == ComponentType.Const)
            {
                components.RemoveAt(const_index);
                components.Insert(0, new ComponentInfo(ComponentType.Const));
            }

            DemangleComponents(components, 0, output);
        }
    }

    static void DemangleComponents(IList<ComponentInfo> components, int start, StringBuilder output)
    {
        if (components.Count == 0)
            return;

        ComponentType last = components[start].type;

        bool isUnsigned = false;
        while (start < components.Count)
        {
            if (components[start].type != last)
            {
                output.Append(' ');
                last = components[start].type;
            }

            switch (components[start].type)
            {
                //case ComponentType.Const: output.Append("const"); break;
                //case ComponentType.Pointer: output.Append('*'); break;
                //case ComponentType.Reference: output.Append('&'); break;
                //case ComponentType.Unsigned: output.Append("unsigned"); break;
                //case ComponentType.Ellipsis: output.Append("..."); break;
                //case ComponentType.Void: output.Append("void"); break;
                //case ComponentType.Bool: output.Append("bool"); break;
                //case ComponentType.Char: output.Append("char"); break;
                //case ComponentType.WChar: output.Append("wchar_t"); break;
                //case ComponentType.Short: output.Append("short"); break;
                //case ComponentType.Int: output.Append("int"); break;
                //case ComponentType.Long: output.Append("long"); break;
                //case ComponentType.LongLong: output.Append("long long"); break;
                //case ComponentType.Float: output.Append("float"); break;
                //case ComponentType.Double: output.Append("double"); break;

                // We want to output to Custom typedefs instead of the default types
                // I'm keeping the default types here for future reference though

                case ComponentType.Const: output.Append("const"); break;
                case ComponentType.Pointer: output.Append('*'); break;
                case ComponentType.Reference: output.Append('&'); break;
                case ComponentType.Unsigned: isUnsigned = true; break;
                case ComponentType.Ellipsis: output.Append("..."); break;
                case ComponentType.Void: output.Append("void"); break;
                case ComponentType.Bool: output.Append("bool"); break;
                case ComponentType.Char: //Okay this is special 'cause we want const char* to be a string without it saying u8
                    if (components.Count == 3 &&
                        components[0].type == ComponentType.Const &&
                        components[1].type == ComponentType.Char &&
                        components[2].type == ComponentType.Pointer)
                        output.Append("char");
                    else
                        output.Append(isUnsigned ? "u8" : "s8");
                    break;
                case ComponentType.WChar: output.Append("wchar_t"); break;
                case ComponentType.Short: output.Append(isUnsigned ? "u16" : "s16"); break;
                case ComponentType.Int: output.Append("int"); break; // Apparently we didn't change int...
                case ComponentType.Long: output.Append(isUnsigned ? "u32" : "s32"); break;
                case ComponentType.LongLong: output.Append(isUnsigned ? "u64" : "s64"); break;
                case ComponentType.Float: output.Append("f32"); break;
                case ComponentType.Double: output.Append("f64"); break;
                case ComponentType.Type: output.Append(components[start].name); break;
                case ComponentType.Func:
                    output.Append(components[start].name);
                    output.Append(' ');

                    if ((start + 1) < components.Count)
                    {
                        output.Append('(');
                        DemangleComponents(components, (start + 1), output);
                        output.Append(") ");
                    }

                    output.Append('(');
                    output.Append(components[start].prms);
                    output.Append(')');
                    return;
                case ComponentType.Array:
                    int count = 0;

                    while ((start + count) < components.Count && components[start + count].type == ComponentType.Array)
                        ++count;

                    if (count > 0 && (start + count) < components.Count)
                    {
                        output.Append('(');
                        DemangleComponents(components, (start + count), output);
                        output.Append(") ");
                    }

                    // output in reverse, e.g. "A4_A3_" becomes "[3][4]"
                    while (count-- > 0)
                    {
                        output.Append('[');
                        output.Append(components[start + count].length);
                        output.Append(']');
                    }
                    return;
            }

            ++start;
        }
    }

    static void DemangleTemplate(StringStream input, StringBuilder output)
    {
        output.Append('<');
        bool end = false;

        do
        {
            DemangleType(input, output);

            switch (input.Read())
            {
                case '>':
                    end = true;
                    break;
                case ',':
                    output.Append(", ");
                    break;
            }
        } while (!end);

        output.Append('>');
    }

    enum ComponentType
    {
        Const,
        Pointer,
        Reference,
        Unsigned,
        Ellipsis,
        Void,
        Bool,
        Char,
        WChar,
        Short,
        Int,
        Long,
        LongLong,
        Float,
        Double,
        Type,
        Func,
        Array,
    }

    struct ComponentInfo(ComponentType type, int length, string name, string prms)
    {
        public ComponentType type = type;
        public int length = length; // array dimension length
        public string name = name; // user type or return type
        public string prms = prms; // parameter types

        public ComponentInfo(ComponentType type) : this(type, 0, "", "") { }
        public ComponentInfo(int length) : this(ComponentType.Array, length, "", "") { }
        public ComponentInfo(string name) : this(ComponentType.Type, 0, name, "") { }
        public ComponentInfo(string prms, string ret) : this(ComponentType.Func, 0, ret, prms) { }

        public override readonly string ToString() => type.ToString();
    }

    class StringStream(string data)
    {
        public string Data { get; private set; } = data;
        public int Position { get; set; } = 0;
        public int Length => Data.Length;

        public char this[int index] => index >= Length ? '\0' : Data[index];
        public char Read() => Position >= Length ? '\0' : Data[Position++];
        public char Peek() => Position >= Length ? '\0' : Data[Position];
    }
}